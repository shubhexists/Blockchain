const expect = require('chai').expect;
const truffleAssert = require('truffle-assertions');

const contractDefinition = artifacts.require('Verifier');
const proofFromFile = require("../../zokrates/code/proof.json");
let proofAsUint;
contract('Verifier', accounts => {
    before(async() => { 
        contractInstance = await contractDefinition.new({from: accounts[0]});
        proofAsUint = getProofAsUint();
    });

    it('should verify true with the correct proof and emit event', async() => {
        let tx = await contractInstance.verifyTx(
            proofAsUint.proof.A,
            proofAsUint.proof.A_p,
            proofAsUint.proof.B,
            proofAsUint.proof.B_p,
            proofAsUint.proof.C,
            proofAsUint.proof.C_p,
            proofAsUint.proof.H,
            proofAsUint.proof.K,
            proofAsUint.input
        );

        truffleAssert.eventEmitted(tx, 'Verified', (ev) => {
            return expect(ev.s).to.deep.equal("Transaction successfully verified.");
        });
    });

    it('should verify false with the incorrect proof and not emit event', async() => {
        let tx = await contractInstance.verifyTx(
            proofAsUint.proof.A,
            proofAsUint.proof.A_p,
            proofAsUint.proof.B,
            proofAsUint.proof.B_p,
            proofAsUint.proof.C_p, //should be proof.C insteaf of C_p
            proofAsUint.proof.C_p,
            proofAsUint.proof.H,
            proofAsUint.proof.K,
            proofAsUint.input
        );

        truffleAssert.eventNotEmitted(tx, 'Verified');
    });

    it('should verify false with the incorrect proof for the input and not emit event', async() => {
        let tx = await contractInstance.verifyTx(
            proofAsUint.proof.A,
            proofAsUint.proof.A_p,
            proofAsUint.proof.B,
            proofAsUint.proof.B_p,
            proofAsUint.proof.C,
            proofAsUint.proof.C_p,
            proofAsUint.proof.H,
            proofAsUint.proof.K,
            [16,1] //proof{A,B,C..} from inside proof.json is bound for input [9,1] and not [16,1]
        );

        truffleAssert.eventNotEmitted(tx, 'Verified');
    });
    
});

const getProofAsUint = () => {
    return {
        "proof": {
            "A": [web3.utils.toBN(proofFromFile.proof.A[0]).toString(), web3.utils.toBN(proofFromFile.proof.A[1]).toString()],
            "A_p": [web3.utils.toBN(proofFromFile.proof.A_p[0]).toString(), web3.utils.toBN(proofFromFile.proof.A_p[1]).toString()],
            "B": [[web3.utils.toBN(proofFromFile.proof.B[0][0]).toString(), web3.utils.toBN(proofFromFile.proof.B[0][1]).toString()],
                [web3.utils.toBN(proofFromFile.proof.B[1][0]).toString(), web3.utils.toBN(proofFromFile.proof.B[1][1]).toString()]
            ],
            "B_p": [web3.utils.toBN(proofFromFile.proof.B_p[0]).toString(), web3.utils.toBN(proofFromFile.proof.B_p[1]).toString()],
            "C": [web3.utils.toBN(proofFromFile.proof.C[0]).toString(), web3.utils.toBN(proofFromFile.proof.C[1]).toString()],
            "C_p": [web3.utils.toBN(proofFromFile.proof.C_p[0]).toString(), web3.utils.toBN(proofFromFile.proof.C_p[1]).toString()],
            "H": [web3.utils.toBN(proofFromFile.proof.H[0]).toString(), web3.utils.toBN(proofFromFile.proof.H[1]).toString()],
            "K": [web3.utils.toBN(proofFromFile.proof.K[0]).toString(), web3.utils.toBN(proofFromFile.proof.K[1]).toString()]
        },
        "input": proofFromFile.input
    };
};
// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates

// Test verification with correct proof
// - use the contents from proof.json generated from zokrates steps

    
// Test verification with incorrect proof
